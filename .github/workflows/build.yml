name: CI-CD
# CI/CD Pipeline for Morpheus Lumerin Node
# 
# Branch Strategy:
#   ‚Ä¢ dev: Build and test only (no deployment)
#   ‚Ä¢ test: Build, test, and deploy to AWS DEV environment
#   ‚Ä¢ main: Build, test, create release, and deploy to AWS PRD environment
#
# Key Features:
#   ‚Ä¢ Optimized Docker builds with GitHub Actions caching
#   ‚Ä¢ Multi-platform container images (linux/amd64, linux/arm64)
#   ‚Ä¢ Cross-platform executables (Linux, macOS, Windows)
#   ‚Ä¢ Automated deployments to AWS Environments via GitHub Actions (both Titan and Morpheus)
#   ‚Ä¢ Health check verification with version matching

on:
  workflow_dispatch:
    inputs:
      create_release:
        description: "Create updated Morpheus-Lumerin-Node release"
        required: true
        type: boolean
      build_all_os:
        description: "Build all OS & container image"
        required: true
        type: boolean
      create_deployment:
        description: "Deploy to hosted environments"
        required: true
        type: boolean

  push:
    branches:
      - main
      - test
      - dev
      - cicd/*

    paths: [".github/**", "ui-desktop/**", "ui-core/**", "proxy-router/**", "cli/**"]

  # pull_request:
  #   types: [opened, reopened, synchronize]
  #   paths: [".github/**", "ui-desktop/**", "ui-core/**", "proxy-router/**", "cli/**"]

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

env:
  TEST_ENV_VAR: "test"

jobs:
  Generate-Tag:
    runs-on: ubuntu-latest
    name: Generate Tag Name
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (startsWith(github.ref, 'refs/heads/cicd/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test' || github.ref == 'refs/heads/dev')) ||
        (github.event_name == 'workflow_dispatch') 
      )
    outputs:
      tag_name: ${{ steps.gen_tag_name.outputs.tag_name }}
      vtag: ${{ steps.gen_tag_name.outputs.vtag }}
      vfull: ${{ steps.gen_tag_name.outputs.vfull }}
      image_name: ${{ steps.gen_tag_name.outputs.image_name }}
      artifacts_base_url: ${{ github.server_url }}/${{ github.repository }}/releases/download/${{ steps.gen_tag_name.outputs.tag_name }}
    steps:
      - name: Clone repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Determine tag name
        id: gen_tag_name
        shell: bash
        run: |
          IMAGE_NAME="ghcr.io/morpheusais/morpheus-lumerin-node"
          VMAJ_NEW=5
          VMIN_NEW=0
          VPAT_NEW=0
          set +o pipefail
          VLAST=$(git describe --tags --abbrev=0 --match='v[1-9]*' refs/remotes/origin/main 2>/dev/null | cut -c2-)

          if [ -n "$VLAST" ]; then
              eval $(echo "$VLAST" | awk -F '.' '{print "VMAJ="$1" VMIN="$2" VPAT="$3}')
          else
              VMAJ=0
              VMIN=0
              VPAT=0
          fi

          if [ "$GITHUB_REF_NAME" = "main" ]; then
              if [ "$VMAJ_NEW" -gt "$VMAJ" ]; then
                  VMAJ=$VMAJ_NEW
                  VMIN=$VMIN_NEW
                  VPAT=$VPAT_NEW
              else
                  VMIN=$((VMIN+1))
                  VPAT=0
              fi
              VFULL=${VMAJ}.${VMIN}.${VPAT}
              VTAG=v$VFULL
          else
              MB=$(git merge-base refs/remotes/origin/main HEAD)
              VPAT=$(git rev-list --count --no-merges ${MB}..HEAD)
              VFULL=${VMAJ}.${VMIN}.${VPAT}
              RNAME=${GITHUB_REF_NAME##*/}
              [ "$GITHUB_EVENT_NAME" = "pull_request" ] && RNAME=pr${GITHUB_REF_NAME%/merge}
              VTAG=v${VFULL}-${RNAME}
          fi

          # Output variables for use in subsequent jobs environment
          echo "tag_name=${VTAG}" >> $GITHUB_OUTPUT
          echo "vtag=${VTAG}" >> $GITHUB_OUTPUT
          echo "vfull=${VFULL}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "‚úÖ New Build Tag: $VTAG" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Docker Image: ${IMAGE_NAME}:${VTAG}" >> $GITHUB_STEP_SUMMARY
          echo "‚ùå Old Major Tag: $VLAST"  >> $GITHUB_STEP_SUMMARY

  Build-Proxy-Router-Test:
    name: Test Proxy Router Docker Image
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (startsWith(github.ref, 'refs/heads/cicd/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test' || github.ref == 'refs/heads/dev')) ||
        (github.event_name == 'workflow_dispatch') 
      )
    runs-on: ubuntu-latest
    needs: Generate-Tag
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Docker Image to Test
        run: |
          BUILDTAG=${{ needs.Generate-Tag.outputs.tag_name }}
          BUILDIMAGE=${{ needs.Generate-Tag.outputs.image_name }}
          BUILDCOMMIT=${{ github.sha }}
          docker buildx build \
            --platform linux/amd64 \
            --build-arg TAG_NAME=$BUILDTAG \
            --build-arg COMMIT=$BUILDCOMMIT \
            --cache-from type=gha \
            --cache-to type=gha,mode=min \
            --load \
            -t $BUILDIMAGE:$BUILDTAG \
            -f proxy-router/Dockerfile \
            proxy-router || (echo "‚ùå Failed to build image with tag: $BUILDIMAGE:$BUILDTAG" && exit 1)
          echo "‚úÖ Proxy-Router Test Build Successful!"

      - name: Run Docker Tests
        uses: ./.github/actions/docker_test
        with:
          image: "${{ needs.Generate-Tag.outputs.image_name }}:${{ needs.Generate-Tag.outputs.tag_name }}"
          private_key: ${{ secrets.TEST_PRIVATE_KEY }}

  GHCR-Build-and-Push:
    name: Build & Push Docker Image
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (startsWith(github.ref, 'refs/heads/cicd/')|| github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.build_all_os == 'true') 
      )
    needs:
      - Generate-Tag
      - Build-Proxy-Router-Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Multi-Platform Docker Image
        run: |
          BUILDTAG=${{ needs.Generate-Tag.outputs.tag_name }}
          BUILDIMAGE=${{ needs.Generate-Tag.outputs.image_name }}
          BUILDCOMMIT=${{ github.sha }}
          
          # Use single platform for test builds and feature branches, multi-platform for main
          if [ "${{ github.ref_name }}" == "test" ] || [[ "${{ github.ref_name }}" == feat/* ]]; then
            PLATFORMS="linux/amd64"
            echo "üöÄ Building single platform (amd64) for faster test deployment"
          else
            PLATFORMS="linux/amd64,linux/arm64"
            echo "üöÄ Building multi-platform for production release"
          fi
          
          docker buildx build \
            --platform $PLATFORMS \
            --build-arg TAG_NAME=$BUILDTAG \
            --build-arg COMMIT=$BUILDCOMMIT \
            --cache-from type=gha \
            --cache-to type=gha,mode=min \
            --push \
            -t $BUILDIMAGE:$BUILDTAG \
            -f proxy-router/Dockerfile \
            proxy-router || (echo "‚ùå Failed to push image with tag: $BUILDIMAGE:$BUILDTAG" && exit 1)
          echo "‚úÖ Proxy-Router Build and Push of $BUILDIMAGE:$BUILDTAG Successful!"

      - name: Optionally Push Latest Tag
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          BUILDIMAGE=${{ needs.Generate-Tag.outputs.image_name }}
          BUILDTAG=${{ needs.Generate-Tag.outputs.tag_name }}
          docker pull $BUILDIMAGE:$BUILDTAG || (echo "‚ùå Failed to pull image: $BUILDIMAGE:$BUILDTAG" && exit 1)
          docker tag $BUILDIMAGE:$BUILDTAG $BUILDIMAGE:latest || (echo "‚ùå Failed to tag image as :latest" && exit 1)
          docker push $BUILDIMAGE:latest || (echo "‚ùå Failed to push image as :latest" && exit 1)
          echo "‚úÖ Proxy-Router Push $BUILDIMAGE:latest Tag Successful!"

  Build-Service-Executables:
    name: Build Service Executables
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (startsWith(github.ref, 'refs/heads/cicd/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.build_all_os == 'true') 
      )
    needs: Generate-Tag
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.22.x"
          cache-dependency-path: |
            proxy-router/go.sum
            cli/go.sum

      - name: Cache Go build artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-build-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-build-

      - name: Build proxy-router executables for all platforms 
        run: |
          FULLTAG=${{ needs.Generate-Tag.outputs.vfull }}
          cd proxy-router
          
          # Pre-download dependencies once
          go mod download
          
          # Build all platforms in parallel using background jobs
          echo "üöÄ Building proxy-router executables..."

          # Linux X64
          echo "üöÄ Building Linux X64 executable..."
          TAG_NAME=${{ needs.Generate-Tag.outputs.tag_name }} GOOS=linux GOARCH=amd64 OUTPUT=proxy-router-${FULLTAG}-linux-amd64 ./build.sh || (echo "‚ùå Failed to build Linux X64 executable" && exit 1)
          mv proxy-router linux-x86_64-morpheus-router-${FULLTAG}
          
          # macOS Intel
          echo "üöÄ Building macOS X64 executable..."
          TAG_NAME=${{ needs.Generate-Tag.outputs.tag_name }} GOOS=darwin GOARCH=amd64 OUTPUT=proxy-router-${FULLTAG}-mac-amd64 ./build.sh || (echo "‚ùå Failed to build macOS X64 executable" && exit 1)
          mv proxy-router mac-x64-morpheus-router-${FULLTAG}
          
          # macOS ARM (Apple Silicon)
          echo "üöÄ Building macOS ARM64 executable..."
          TAG_NAME=${{ needs.Generate-Tag.outputs.tag_name }} GOOS=darwin GOARCH=arm64 OUTPUT=proxy-router-${FULLTAG}-mac-arm64 ./build.sh || (echo "‚ùå Failed to build macOS ARM64 executable" && exit 1)
          mv proxy-router mac-arm64-morpheus-router-${FULLTAG}
          
          # Windows X64
          echo "üöÄ Building Windows X64 executable..."
          TAG_NAME=${{ needs.Generate-Tag.outputs.tag_name }} GOOS=windows GOARCH=amd64 OUTPUT=proxy-router-${FULLTAG}-win-amd64.exe ./build.sh || (echo "‚ùå Failed to build Windows X64 executable" && exit 1)
          mv proxy-router win-x64-morpheus-router-${FULLTAG}.exe
          
          echo "‚úÖ Built Proxy Router executables for all platforms"

      - name: Build CLI Executables for all platforms
        run: |
          FULLTAG=${{ needs.Generate-Tag.outputs.vfull }}
          cd cli
          
          # Pre-download dependencies once
          go mod download
          
          # Build all platforms in parallel
          echo "üöÄ Building CLI executables..."
          
          # Linux X64
          echo "üöÄ Building Linux X64 CLI executable..."
          GOOS=linux GOARCH=amd64 make build || (echo "‚ùå Failed to build Linux X64 executable" && exit 1)
          mv mor-cli linux-x86_64-morpheus-cli-${FULLTAG}
          
          # macOS Intel
          echo "üöÄ Building macOS X64 CLI executable..."
          GOOS=darwin GOARCH=amd64 make build || (echo "‚ùå Failed to build macOS X64 executable" && exit 1)
          mv mor-cli mac-x64-morpheus-cli-${FULLTAG}
          
          # macOS ARM (Apple Silicon)
          echo "üöÄ Building macOS ARM64 CLI executable..."
          GOOS=darwin GOARCH=arm64 make build || (echo "‚ùå Failed to build macOS ARM64 executable" && exit 1)
          mv mor-cli mac-arm64-morpheus-cli-${FULLTAG}
          
          # Windows X64
          echo "üöÄ Building Windows X64 CLI executable..."
          GOOS=windows GOARCH=amd64 make build || (echo "‚ùå Failed to build Windows X64 executable" && exit 1)
          mv mor-cli win-x64-morpheus-cli-${FULLTAG}.exe
          
          echo "‚úÖ Built CLI executables for all platforms"


      - name: Upload CLI artifacts
        uses: actions/upload-artifact@v4
        with:
          name: cli
          path: |
            cli/linux-x86_64-morpheus-cli-${{ needs.Generate-Tag.outputs.vfull }}
            cli/mac-x64-morpheus-cli-${{ needs.Generate-Tag.outputs.vfull }}
            cli/mac-arm64-morpheus-cli-${{ needs.Generate-Tag.outputs.vfull }}
            cli/win-x64-morpheus-cli-${{ needs.Generate-Tag.outputs.vfull }}.exe
    
      - name: Upload ProxyRouter artifacts
        uses: actions/upload-artifact@v4
        with:
          name: proxy-router
          path: |
            proxy-router/linux-x86_64-morpheus-router-${{ needs.Generate-Tag.outputs.vfull }}
            proxy-router/mac-x64-morpheus-router-${{ needs.Generate-Tag.outputs.vfull }}
            proxy-router/mac-arm64-morpheus-router-${{ needs.Generate-Tag.outputs.vfull }}
            proxy-router/win-x64-morpheus-router-${{ needs.Generate-Tag.outputs.vfull }}.exe

  Deploy-to-Titan:
    name: Deploy to Titan via GitHub Actions
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.build_all_os == 'true' && github.event.inputs.create_deployment == 'true')
      )
    needs:
      - Generate-Tag
      - GHCR-Build-and-Push
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.TITAN_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.TITAN_AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy to Titan ECS
        run: |
          # For deployment, use the newly built image
          BUILDTAG=${{ needs.Generate-Tag.outputs.tag_name }}
          BUILDIMAGE=${{ needs.Generate-Tag.outputs.image_name }}
          
          # Determine environment based on branch
          if [ "${{ github.ref_name }}" == "test" ]; then
            ENV="dev"
          elif [ "${{ github.ref_name }}" == "main" ]; then
            ENV="lmn"
          else
            echo "‚ùå Unsupported branch for deployment: ${{ github.ref_name }}"
            exit 1
          fi
          
          echo "üöÄ Deploying to Titan AWS - Environment: $ENV"
          echo "üì¶ Container Image: $BUILDIMAGE:$BUILDTAG"
          
          # ECS deployment variables
          CLUSTER_NAME="ecs-morpheus-router-${ENV}-use1"
          SERVICE_NAME="svc-morpheus-router-${ENV}-use1"
          TASK_FAMILY="tsk-morpheus-router"
          CONTAINER_NAME="morpheus-router-container"
          
          # Get current task definition
          echo "üìã Retrieving current task definition..."
          CURRENT_TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$TASK_FAMILY" \
            --query 'taskDefinition' \
            --output json)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to retrieve current task definition"
            exit 1
          fi
          
          # Update the image in the task definition
          echo "üîÑ Creating new task definition with image: $BUILDIMAGE:$BUILDTAG"
          NEW_TASK_DEF=$(echo "$CURRENT_TASK_DEF" | jq --arg IMAGE "$BUILDIMAGE:$BUILDTAG" --arg CONTAINER "$CONTAINER_NAME" '
            {
              family: .family,
              networkMode: .networkMode,
              requiresCompatibilities: .requiresCompatibilities,
              cpu: .cpu,
              memory: .memory,
              taskRoleArn: .taskRoleArn,
              executionRoleArn: .executionRoleArn,
              volumes: .volumes,
              containerDefinitions: (.containerDefinitions | map(
                if .name == $CONTAINER then
                  .image = $IMAGE
                else
                  .
                end
              ))
            }
          ')
          
          # Debug: Check if JSON is valid
          echo "üîç Validating JSON structure..."
          echo "$NEW_TASK_DEF" | jq empty
          if [ $? -ne 0 ]; then
            echo "‚ùå Generated JSON is invalid"
            echo "Generated JSON:"
            echo "$NEW_TASK_DEF"
            exit 1
          fi
          
          # Debug: Show task definition summary
          echo "üîç Task definition summary:"
          echo "$NEW_TASK_DEF" | jq '.family, .cpu, .memory, .networkMode, .requiresCompatibilities, (.containerDefinitions | length)'
          
          # Register new task definition
          echo "üìù Registering new task definition..."
          
          # Save JSON to temporary file to avoid stdin issues
          TEMP_JSON_FILE="/tmp/task_definition_$$.json"
          echo "$NEW_TASK_DEF" > "$TEMP_JSON_FILE"
          
          # Validate the temp file
          jq empty "$TEMP_JSON_FILE"
          if [ $? -ne 0 ]; then
            echo "‚ùå Temporary file contains invalid JSON"
            rm -f "$TEMP_JSON_FILE"
            exit 1
          fi
          
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "file://$TEMP_JSON_FILE" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          # Clean up temp file
          rm -f "$TEMP_JSON_FILE"
          
          if [ $? -ne 0 ] || [ -z "$NEW_TASK_ARN" ]; then
            echo "‚ùå Failed to register new task definition"
            exit 1
          fi
          
          echo "‚úÖ New task definition registered: $NEW_TASK_ARN"
          
          # Update the ECS service
          echo "üîÑ Updating ECS service..."
          UPDATE_RESULT=$(aws ecs update-service \
            --cluster "$CLUSTER_NAME" \
            --service "$SERVICE_NAME" \
            --task-definition "$NEW_TASK_ARN" \
            --force-new-deployment \
            --query 'service.{serviceName:serviceName,taskDefinition:taskDefinition,desiredCount:desiredCount,runningCount:runningCount,pendingCount:pendingCount}' \
            --output json)
          
          echo "üìä Service Update Summary:"
          echo "$UPDATE_RESULT" | jq .
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to update ECS service"
            exit 1
          fi
          
          echo "‚úÖ ECS service update initiated successfully"
          echo "üéØ Environment: $ENV"
          echo "üèóÔ∏è  Cluster: $CLUSTER_NAME"
          echo "‚öôÔ∏è  Service: $SERVICE_NAME"
          echo "üì¶ Image: $BUILDIMAGE:$BUILDTAG"
          echo "üìã Task Definition: $NEW_TASK_ARN"
          
          # Wait for deployment to stabilize with extended timeout
          echo "‚è≥ Waiting for service to stabilize (up to 15 minutes)..."
          aws ecs wait services-stable \
            --cluster "$CLUSTER_NAME" \
            --services "$SERVICE_NAME" \
            --cli-read-timeout 900 \
            --cli-connect-timeout 60
          
          STABILIZATION_STATUS=$?
          
          if [ $STABILIZATION_STATUS -eq 0 ]; then
            echo "‚úÖ ECS service stabilized successfully"
          else
            echo "‚ö†Ô∏è ECS stabilization wait timed out, but continuing with health check..."
          fi
          
          # Determine the public endpoint for health check
          if [ "$ENV" == "dev" ]; then
            HEALTH_ENDPOINT="http://morpheusapi.dev.titan.io:8082/healthcheck"
          elif [ "$ENV" == "lmn" ]; then
            HEALTH_ENDPOINT="http://morpheusapi.titan.io:8082/healthcheck"
          fi
          
          echo "üîç Verifying deployment version at: $HEALTH_ENDPOINT"
          
          # Wait for the service to be reachable and verify version
          MAX_HEALTH_RETRIES=20
          HEALTH_RETRY_COUNT=0
          VERSION_VERIFIED=false
          
          while [ $HEALTH_RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; do
            echo "üîÑ Health check attempt $((HEALTH_RETRY_COUNT + 1))/$MAX_HEALTH_RETRIES..."
            
            # Get health check response
            HEALTH_RESPONSE=$(curl -s --max-time 10 "$HEALTH_ENDPOINT" 2>/dev/null)
            CURL_STATUS=$?
            
            if [ $CURL_STATUS -eq 0 ] && [ -n "$HEALTH_RESPONSE" ]; then
              echo "üì° Health response: $HEALTH_RESPONSE"
              
              # Parse version from JSON response
              DEPLOYED_VERSION=$(echo "$HEALTH_RESPONSE" | jq -r '.Version // empty' 2>/dev/null)
              UPTIME=$(echo "$HEALTH_RESPONSE" | jq -r '.Uptime // empty' 2>/dev/null)
              STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.Status // empty' 2>/dev/null)
              
              if [ -n "$DEPLOYED_VERSION" ] && [ "$STATUS" = "healthy" ]; then
                echo "üè• Service Status: $STATUS"
                echo "üì¶ Deployed Version: $DEPLOYED_VERSION"
                echo "‚è∞ Service Uptime: $UPTIME"
                
                # Check if deployed version matches expected version
                if [[ "$DEPLOYED_VERSION" == *"$BUILDTAG"* ]] || [[ "$BUILDTAG" == *"$DEPLOYED_VERSION"* ]]; then
                  echo "‚úÖ Version verification successful! Deployed version matches expected tag."
                  VERSION_VERIFIED=true
                  break
                else
                  echo "‚ö†Ô∏è Version mismatch - Expected: $BUILDTAG, Deployed: $DEPLOYED_VERSION"
                fi
              else
                echo "‚ö†Ô∏è Service not healthy or version not available"
              fi
            else
              echo "‚ö†Ô∏è Health check failed (curl status: $CURL_STATUS)"
            fi
            
            HEALTH_RETRY_COUNT=$((HEALTH_RETRY_COUNT + 1))
            if [ $HEALTH_RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; then
              echo "‚è≥ Waiting 15 seconds before retry..."
              sleep 15
            fi
          done
          
          # Final deployment status
          if [ "$VERSION_VERIFIED" = true ]; then
            echo ""
            echo "üéâ Deployment completed successfully!"
            echo "‚úÖ Service is healthy and running the expected version"
            echo "üåê Health Check URL: $HEALTH_ENDPOINT"
          else
            echo ""
            echo "‚ùå Deployment verification failed!"
            echo "üîç The service may still be starting up or there may be an issue"
            echo "üåê Manual check: $HEALTH_ENDPOINT"
            echo "üèóÔ∏è  Expected version: $BUILDTAG"
            if [ -n "$DEPLOYED_VERSION" ]; then
              echo "üì¶ Currently deployed: $DEPLOYED_VERSION"
            fi
            echo ""
            echo "‚ÑπÔ∏è This may be a temporary issue. Check the health endpoint in a few minutes."
            echo "‚ÑπÔ∏è If the issue persists, check AWS ECS console and CloudWatch logs."
            
            # Don't fail the deployment for version mismatch, as it might be a timing issue
            # The ECS service update was successful, version verification is informational
            echo "‚ö†Ô∏è Continuing with warning - ECS deployment completed but version verification inconclusive"
          fi

  Deploy-to-Morpheus:
    name: Deploy to Morpheus via GitHub
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test'))||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.build_all_os == 'true' && github.event.inputs.create_deployment == 'true')
      )
    needs:
      - Generate-Tag
      - GHCR-Build-and-Push  
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.MORPHEUS_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.MORPHEUS_AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-2

      - name: Deploy to Morpheus ECS
        run: |
          # For deployment testing, use existing image instead of newly built one
          BUILDTAG=${{ needs.Generate-Tag.outputs.tag_name }}
          BUILDIMAGE=${{ needs.Generate-Tag.outputs.image_name }}
          
          # Determine environment based on branch
          if [ "${{ github.ref_name }}" == "test" ]; then
            ENV="dev"
          elif [ "${{ github.ref_name }}" == "main" ]; then
            ENV="prd"
          else
            echo "‚ùå Unsupported branch for deployment: ${{ github.ref_name }}"
            exit 1
          fi
          
          echo "üöÄ Deploying to Morpheus AWS - Environment: $ENV"
          echo "üì¶ Container Image: $BUILDIMAGE:$BUILDTAG"
          
          # ECS deployment variables
          CLUSTER_NAME="ecs-${ENV}-morpheus-engine"
          SERVICE_NAME="svc-${ENV}-router"
          TASK_FAMILY="tsk-${ENV}-router"
          CONTAINER_NAME="router-container"
          
          # Get current task definition
          echo "üìã Retrieving current task definition..."
          CURRENT_TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$TASK_FAMILY" \
            --query 'taskDefinition' \
            --output json)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to retrieve current task definition"
            exit 1
          fi
          
          # Update the image in the task definition
          echo "üîÑ Creating new task definition with image: $BUILDIMAGE:$BUILDTAG"
          NEW_TASK_DEF=$(echo "$CURRENT_TASK_DEF" | jq --arg IMAGE "$BUILDIMAGE:$BUILDTAG" --arg CONTAINER "$CONTAINER_NAME" '
            {
              family: .family,
              networkMode: .networkMode,
              requiresCompatibilities: .requiresCompatibilities,
              cpu: .cpu,
              memory: .memory,
              taskRoleArn: .taskRoleArn,
              executionRoleArn: .executionRoleArn,
              volumes: .volumes,
              containerDefinitions: (.containerDefinitions | map(
                if .name == $CONTAINER then
                  .image = $IMAGE
                else
                  .
                end
              ))
            }
          ')
          
          # Debug: Check if JSON is valid
          echo "üîç Validating JSON structure..."
          echo "$NEW_TASK_DEF" | jq empty
          if [ $? -ne 0 ]; then
            echo "‚ùå Generated JSON is invalid"
            echo "Generated JSON:"
            echo "$NEW_TASK_DEF"
            exit 1
          fi
          
          # Debug: Show task definition summary
          echo "üîç Task definition summary:"
          echo "$NEW_TASK_DEF" | jq '.family, .cpu, .memory, .networkMode, .requiresCompatibilities, (.containerDefinitions | length)'
          
          # Register new task definition
          echo "üìù Registering new task definition..."
          
          # Save JSON to temporary file to avoid stdin issues
          TEMP_JSON_FILE="/tmp/task_definition_$$.json"
          echo "$NEW_TASK_DEF" > "$TEMP_JSON_FILE"
          
          # Validate the temp file
          jq empty "$TEMP_JSON_FILE"
          if [ $? -ne 0 ]; then
            echo "‚ùå Temporary file contains invalid JSON"
            rm -f "$TEMP_JSON_FILE"
            exit 1
          fi
          
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "file://$TEMP_JSON_FILE" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          # Clean up temp file
          rm -f "$TEMP_JSON_FILE"
          
          if [ $? -ne 0 ] || [ -z "$NEW_TASK_ARN" ]; then
            echo "‚ùå Failed to register new task definition"
            exit 1
          fi
          
          echo "‚úÖ New task definition registered: $NEW_TASK_ARN"
          
          # Update the ECS service
          echo "üîÑ Updating ECS service..."
          UPDATE_RESULT=$(aws ecs update-service \
            --cluster "$CLUSTER_NAME" \
            --service "$SERVICE_NAME" \
            --task-definition "$NEW_TASK_ARN" \
            --force-new-deployment \
            --query 'service.{serviceName:serviceName,taskDefinition:taskDefinition,desiredCount:desiredCount,runningCount:runningCount,pendingCount:pendingCount}' \
            --output json)
          
          echo "üìä Service Update Summary:"
          echo "$UPDATE_RESULT" | jq .
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to update ECS service"
            exit 1
          fi
          
          echo "‚úÖ ECS service update initiated successfully"
          echo "üéØ Environment: $ENV"
          echo "üèóÔ∏è  Cluster: $CLUSTER_NAME"
          echo "‚öôÔ∏è  Service: $SERVICE_NAME"
          echo "üì¶ Image: $BUILDIMAGE:$BUILDTAG"
          echo "üìã Task Definition: $NEW_TASK_ARN"
          
          # Wait for deployment to stabilize with extended timeout
          echo "‚è≥ Waiting for service to stabilize (up to 15 minutes)..."
          aws ecs wait services-stable \
            --cluster "$CLUSTER_NAME" \
            --services "$SERVICE_NAME" \
            --cli-read-timeout 900 \
            --cli-connect-timeout 60
          
          STABILIZATION_STATUS=$?
          
          if [ $STABILIZATION_STATUS -eq 0 ]; then
            echo "‚úÖ ECS service stabilized successfully"
          else
            echo "‚ö†Ô∏è ECS stabilization wait timed out, but continuing with health check..."
          fi
          
          # Determine the public endpoint for health check
          if [ "$ENV" == "dev" ]; then
            HEALTH_ENDPOINT="http://router.dev.mor.org:8082/healthcheck"
          elif [ "$ENV" == "prd" ]; then
            HEALTH_ENDPOINT="http://router.mor.org:8082/healthcheck"
          fi
          
          echo "üîç Verifying deployment version at: $HEALTH_ENDPOINT"
          
          # Wait for the service to be reachable and verify version
          MAX_HEALTH_RETRIES=20
          HEALTH_RETRY_COUNT=0
          VERSION_VERIFIED=false
          
          while [ $HEALTH_RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; do
            echo "üîÑ Health check attempt $((HEALTH_RETRY_COUNT + 1))/$MAX_HEALTH_RETRIES..."
            
            # Get health check response
            HEALTH_RESPONSE=$(curl -s --max-time 10 "$HEALTH_ENDPOINT" 2>/dev/null)
            CURL_STATUS=$?
            
            if [ $CURL_STATUS -eq 0 ] && [ -n "$HEALTH_RESPONSE" ]; then
              echo "üì° Health response: $HEALTH_RESPONSE"
              
              # Parse version from JSON response
              DEPLOYED_VERSION=$(echo "$HEALTH_RESPONSE" | jq -r '.Version // empty' 2>/dev/null)
              UPTIME=$(echo "$HEALTH_RESPONSE" | jq -r '.Uptime // empty' 2>/dev/null)
              STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.Status // empty' 2>/dev/null)
              
              if [ -n "$DEPLOYED_VERSION" ] && [ "$STATUS" = "healthy" ]; then
                echo "üè• Service Status: $STATUS"
                echo "üì¶ Deployed Version: $DEPLOYED_VERSION"
                echo "‚è∞ Service Uptime: $UPTIME"
                
                # Check if deployed version matches expected version
                if [[ "$DEPLOYED_VERSION" == *"$BUILDTAG"* ]] || [[ "$BUILDTAG" == *"$DEPLOYED_VERSION"* ]]; then
                  echo "‚úÖ Version verification successful! Deployed version matches expected tag."
                  VERSION_VERIFIED=true
                  break
                else
                  echo "‚ö†Ô∏è Version mismatch - Expected: $BUILDTAG, Deployed: $DEPLOYED_VERSION"
                fi
              else
                echo "‚ö†Ô∏è Service not healthy or version not available"
              fi
            else
              echo "‚ö†Ô∏è Health check failed (curl status: $CURL_STATUS)"
            fi
            
            HEALTH_RETRY_COUNT=$((HEALTH_RETRY_COUNT + 1))
            if [ $HEALTH_RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; then
              echo "‚è≥ Waiting 15 seconds before retry..."
              sleep 15
            fi
          done
          
          # Final deployment status
          if [ "$VERSION_VERIFIED" = true ]; then
            echo ""
            echo "üéâ Deployment completed successfully!"
            echo "‚úÖ Service is healthy and running the expected version"
            echo "üåê Health Check URL: $HEALTH_ENDPOINT"
          else
            echo ""
            echo "‚ùå Deployment verification failed!"
            echo "üîç The service may still be starting up or there may be an issue"
            echo "üåê Manual check: $HEALTH_ENDPOINT"
            echo "üèóÔ∏è  Expected version: $BUILDTAG"
            if [ -n "$DEPLOYED_VERSION" ]; then
              echo "üì¶ Currently deployed: $DEPLOYED_VERSION"
            fi
            echo ""
            echo "‚ÑπÔ∏è This may be a temporary issue. Check the health endpoint in a few minutes."
            echo "‚ÑπÔ∏è If the issue persists, check AWS ECS console and CloudWatch logs."
            
            # Don't fail the deployment for version mismatch, as it might be a timing issue
            # The ECS service update was successful, version verification is informational
            echo "‚ö†Ô∏è Continuing with warning - ECS deployment completed but version verification inconclusive"
          fi

  UI-macOS-14-arm64:
    name: Build Morpheus UI macOS-arm64 Image
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (startsWith(github.ref, 'refs/heads/cicd/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.build_all_os == 'true')
      )
    runs-on: macos-14
    needs:
      - Generate-Tag
      - Build-Service-Executables
    env:
      SERVICE_PROXY_DOWNLOAD_URL_MAC_ARM64: ${{ needs.Generate-Tag.outputs.artifacts_base_url }}/mac-arm64-morpheus-router-${{ needs.Generate-Tag.outputs.vfull }}
    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "yarn"
          cache-dependency-path: ui-desktop/yarn.lock

      - name: Cache Electron binaries
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/electron
            ~/.cache/electron-builder
          key: ${{ runner.os }}-electron-${{ hashFiles('ui-desktop/package.json') }}
          restore-keys: |
            ${{ runner.os }}-electron-

      - name: Install dependencies
        run: |
          cd ./ui-desktop
          brew install python-setuptools
          yarn install --network-timeout 600000 --frozen-lockfile

      - name: Copy Environment Files
        uses: ./.github/actions/copy_env_files

      - name: Build
        id: build
        run: |
          FULLTAG=${{ needs.Generate-Tag.outputs.vfull }}
          cd ./ui-desktop
          echo "Injecting version $FULLTAG into package.json"
          sed -i "" "s/\"version\": \".*\"/\"version\": \"$FULLTAG\"/" package.json
          cat package.json | grep '"version"'  # Optional: Verify the change
          yarn build:mac-arm64

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          path: ./ui-desktop/dist/mac-arm64-morpheus-app-${{ needs.Generate-Tag.outputs.vfull }}.dmg
          name: mac-arm64-morpheus-app-${{ needs.Generate-Tag.outputs.vfull }}.dmg

  UI-Ubuntu-22-x64:
    name: Build Morpheus UI Ubuntu x64 Image
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (startsWith(github.ref, 'refs/heads/cicd/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.build_all_os == 'true')
      )
    runs-on: ubuntu-22.04
    needs:
      - Generate-Tag
      - Build-Service-Executables
    env:
      SERVICE_PROXY_DOWNLOAD_URL_LINUX_X64: ${{ needs.Generate-Tag.outputs.artifacts_base_url }}/linux-x86_64-morpheus-router-${{ needs.Generate-Tag.outputs.vfull }}
    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "yarn"
          cache-dependency-path: ui-desktop/yarn.lock

      - name: Cache Electron binaries
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/electron
            ~/.cache/electron-builder
          key: ${{ runner.os }}-electron-${{ hashFiles('ui-desktop/package.json') }}
          restore-keys: |
            ${{ runner.os }}-electron-

      - name: Install dependencies
        run: |
          cd ./ui-desktop
          yarn install --network-timeout 600000 --frozen-lockfile

      - name: Copy Environment Files
        uses: ./.github/actions/copy_env_files

      - name: Build
        id: build
        run: |
          FULLTAG=${{ needs.Generate-Tag.outputs.vfull }}
          cd ./ui-desktop
          echo "Injecting version $FULLTAG into package.json"
          sed -i "s/\"version\": \".*\"/\"version\": \"$FULLTAG\"/" package.json
          cat package.json | grep '"version"'  # Optional: Verify the change
          yarn build:linux-x64

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          path: ./ui-desktop/dist/linux-x86_64-morpheus-app-${{ needs.Generate-Tag.outputs.vfull }}.AppImage
          name: linux-x86_64-morpheus-app-${{ needs.Generate-Tag.outputs.vfull }}.AppImage

  UI-macOS-13-x64:
    name: Build Morpheus UI macOS-x64 Image
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (startsWith(github.ref, 'refs/heads/cicd/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.build_all_os == 'true')
      )
    runs-on: macos-13
    needs:
      - Generate-Tag
      - Build-Service-Executables
    env:
      SERVICE_PROXY_DOWNLOAD_URL_MAC_X64: ${{ needs.Generate-Tag.outputs.artifacts_base_url }}/mac-x64-morpheus-router-${{ needs.Generate-Tag.outputs.vfull }}
    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "yarn"
          cache-dependency-path: ui-desktop/yarn.lock

      - name: Cache Electron binaries
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/electron
            ~/.cache/electron-builder
          key: ${{ runner.os }}-electron-${{ hashFiles('ui-desktop/package.json') }}
          restore-keys: |
            ${{ runner.os }}-electron-

      - name: Install dependencies
        run: |
          cd ./ui-desktop
          python3 -m pip install setuptools
          yarn install --network-timeout 600000 --frozen-lockfile

      - name: Copy Environment Files
        uses: ./.github/actions/copy_env_files

      - name: Build
        id: build
        run: |
          FULLTAG=${{ needs.Generate-Tag.outputs.vfull }}
          cd ./ui-desktop
          echo "Injecting version $FULLTAG into package.json"
          sed -i "" "s/\"version\": \".*\"/\"version\": \"$FULLTAG\"/" package.json
          cat package.json | grep '"version"'  # Optional: Verify the change
          yarn build:mac-x64

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          path: ./ui-desktop/dist/mac-x64-morpheus-app-${{ needs.Generate-Tag.outputs.vfull }}.dmg
          name: mac-x64-morpheus-app-${{ needs.Generate-Tag.outputs.vfull }}.dmg

  UI-Windows-avx2-x64:
    name: Build Morpheus UI Windows Image
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (startsWith(github.ref, 'refs/heads/cicd/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.build_all_os == 'true')
      )
    runs-on: windows-latest
    needs:
      - Generate-Tag
      - Build-Service-Executables
    env:
      SERVICE_PROXY_DOWNLOAD_URL_WINDOWS_X64: ${{ needs.Generate-Tag.outputs.artifacts_base_url }}/win-x64-morpheus-router-${{ needs.Generate-Tag.outputs.vfull }}.exe
    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "yarn"
          cache-dependency-path: ui-desktop/yarn.lock

      - name: Cache Electron binaries
        uses: actions/cache@v4
        with:
          path: |
            ~\AppData\Local\electron
            ~\AppData\Local\electron-builder
          key: ${{ runner.os }}-electron-${{ hashFiles('ui-desktop/package.json') }}
          restore-keys: |
            ${{ runner.os }}-electron-

      - name: Cache Chocolatey packages
        uses: actions/cache@v4
        with:
          path: |
            C:\ProgramData\chocolatey\lib
            C:\ProgramData\chocolatey\bin
          key: ${{ runner.os }}-choco-${{ hashFiles('.github/workflows/build.yml') }}
          restore-keys: |
            ${{ runner.os }}-choco-

      - name: Install system tools (optimized)
        run: |
          # Install tools in parallel and with no-progress for speed
          Start-Job -ScriptBlock { choco install wget --no-progress --force }
          Start-Job -ScriptBlock { choco install sed --no-progress --force }
          
          # Wait for both jobs to complete
          Get-Job | Wait-Job
          Get-Job | Receive-Job
          Get-Job | Remove-Job
        shell: powershell

      - name: Install dependencies
        run: |
          cd ./ui-desktop
          yarn install --network-timeout 600000 --frozen-lockfile

      - name: Copy Environment Files
        uses: ./.github/actions/copy_env_files

      - name: Build
        id: build
        run: |
          FULLTAG=${{ needs.Generate-Tag.outputs.vfull }}       
          cd ./ui-desktop
          echo "Injecting version $FULLTAG into package.json"
          sed -i "s/\"version\": \".*\"/\"version\": \"$FULLTAG\"/" package.json
          cat package.json | grep '"version"'  # Optional: Verify the change
          yarn build:win-x64

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          path: ./ui-desktop/dist/win-x64-morpheus-app-${{ needs.Generate-Tag.outputs.vfull }}.exe
          name: win-x64-morpheus-app-${{ needs.Generate-Tag.outputs.vfull }}.exe

  UI-Release:
    name: Upload UI-Desktop Release
    if: |
      github.repository == 'MorpheusAIs/Morpheus-Lumerin-Node' &&
      (
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true')
      )
    needs:
      - Generate-Tag
      - UI-macOS-14-arm64
      - UI-macOS-13-x64
      - UI-Ubuntu-22-x64
      - UI-Windows-avx2-x64

    runs-on: ubuntu-latest
    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Download artifacts
        id: download-artifact
        uses: actions/download-artifact@v4
        with:
          path: ./artifact
          merge-multiple: true
      
      - name: Verify artifact contents
        run: |
          echo "üîç Contents of ./artifact:"
          ls -lh ./artifact
        
      - name: Create release
        id: create_release
        uses: anzz1/action-create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.Generate-Tag.outputs.tag_name }}
          prerelease: ${{ github.ref != 'refs/heads/main' }}

      - name: Upload release
        uses: ./.github/actions/upload_release
        with:
          path: ./artifact
          release_id: ${{ steps.create_release.outputs.id }}
